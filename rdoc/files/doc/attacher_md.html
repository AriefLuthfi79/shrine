<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>attacher.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>attacher.md
</h1>
<div class='paths'>
doc/attacher.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2019-07-15 16:05:48 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Using+Attacher">Using Attacher<span><a href="#label-Using+Attacher">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>The most convenient way to use <a href="../../classes/Shrine.html"><code>Shrine</code></a> is through the model, using the interface provided by Shrine&#39;s attachment module. This way you can interact with the attachment just like with any other column attribute, and adding attachment fields to the form just works.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:image</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<p>However, if you don&#39;t want to add additional methods on the model and prefer explicitness, or you need more control, you can achieve the same behaviour using the <code>Shrine::Attacher</code> object, which is what the attachment interface uses under the hood.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span> = <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, <span class="ruby-value">:image</span>) <span class="ruby-comment"># equivalent to `photo.image_attacher`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">file</span>)                                 <span class="ruby-comment"># equivalent to `photo.image = file`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">get</span>                                          <span class="ruby-comment"># equivalent to `photo.image`</span></pre>

<p>The attacher will use the <code>&lt;attachment&gt;_data</code> attribute for storing information about the attachment.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">data_attribute</span> <span class="ruby-comment">#=&gt; :image_data</span></pre>

<h2 id="label-Initializing">Initializing<span><a href="#label-Initializing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The attacher object exposes the objects it uses:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">record</span> <span class="ruby-comment">#=&gt; #&lt;Photo&gt;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">name</span>   <span class="ruby-comment">#=&gt; :image</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">cache</span>  <span class="ruby-comment">#=&gt; #&lt;ImageUploader @storage_key=:cache&gt;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">store</span>  <span class="ruby-comment">#=&gt; #&lt;ImageUploader @storage_key=:store&gt;</span></pre>

<p>The attacher will automatically use <code>:cache</code> and <code>:store</code> storages, but you can also tell it to use different temporary and permanent storage:</p>

<pre class="ruby"><span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, <span class="ruby-value">:image</span>, <span class="ruby-value">cache:</span> <span class="ruby-value">:other_cache</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:other_store</span>)&#x000A;&#x000A;<span class="ruby-comment"># OR</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_attacher</span>(<span class="ruby-value">cache:</span> <span class="ruby-value">:other_cache</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:other_store</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-identifier">file</span> <span class="ruby-comment"># uploads to :other_cache storage</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>         <span class="ruby-comment"># promotes to :other_store storage</span></pre>

<p>You can pass the <code>:cache</code> and <code>:store</code> options via <code>Attachment.new</code> too:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:image</span>, <span class="ruby-value">cache:</span> <span class="ruby-value">:other_cache</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:other_store</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Note that it&#39;s not necessary to use the temporary storage, see the next section for more details.</p>

<h2 id="label-Assignment">Assignment<span><a href="#label-Assignment">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#assign</code> method accepts either an IO object to be cached, or an already cached file in form of a JSON string, and assigns the cached result to record&#39;s <code>&lt;attachment&gt;_data</code> attribute.</p>

<pre class="ruby"><span class="ruby-comment"># uploads the `io` object to temporary storage, and writes to the data column</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">io</span>)&#x000A;&#x000A;<span class="ruby-comment"># writes the given cached file to the data column</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-string">&#39;{&quot;id&quot;:&quot;9260ea09d8effd.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{ ... }}&#39;</span>)</pre>

<p>When assigning an IO object, any additional options passed to <code>#assign</code> will be forwarded to <code>Shrine#upload</code>. This allows you to do things like overriding metadata, setting upload location, or passing upload options:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span> <span class="ruby-identifier">io</span>,&#x000A;  <span class="ruby-value">metadata:</span>       { <span class="ruby-string">&quot;filename&quot;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;myfile.txt&quot;</span> },&#x000A;  <span class="ruby-value">location:</span>       <span class="ruby-string">&quot;custom/location&quot;</span>,&#x000A;  <span class="ruby-value">upload_options:</span> { <span class="ruby-value">acl:</span> <span class="ruby-string">&quot;public-read&quot;</span> }</pre>

<p>If you&#39;re attaching a cached file and want to override its metadata before assignment, you can do it like so:</p>

<pre class="ruby"><span class="ruby-identifier">cached_file</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">uploaded_file</span>(<span class="ruby-string">&#39;{&quot;id&quot;:&quot;9260ea09d8effd.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{ ... }}&#39;</span>)&#x000A;<span class="ruby-identifier">cached_file</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;filename&quot;</span>] = <span class="ruby-string">&quot;myfile.txt&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">cached_file</span>.<span class="ruby-identifier">to_json</span>)</pre>

<p>For security reasons <code>#assign</code> doesn&#39;t accept files uploaded to permanent storage, but you can use <code>#set</code> to attach any <code>Shrine::UploadedFile</code> object. You can use this to skip temporary storage altogether and upload files directly to permanent storage:</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">store!</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># upload a file directly to permanent storage</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">uploaded_file</span>)          <span class="ruby-comment"># attach the uploaded file</span></pre>

<h2 id="label-Retrieval">Retrieval<span><a href="#label-Retrieval">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#get</code> method reads record&#39;s <code>&lt;attachment&gt;_data</code> attribute, and constructs a <code>Shrine::UploadedFile</code> object from it.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">get</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>

<p>The <code>#read</code> method will just return the value of the underlying <code>&lt;attachment&gt;_data</code> attribute.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">read</span> <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;dsg024lfs.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span></pre>

<p>In general you can use <code>#uploaded_file</code> to contruct a <code>Shrine::UploadedFile</code> from a JSON string.</p>

<pre class="ruby"><span class="ruby-identifier">attachment_data</span> = <span class="ruby-string">&#39;{&quot;id&quot;:&quot;dsg024lfs.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">uploaded_file</span>(<span class="ruby-identifier">attachment_data</span>) <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>

<h2 id="label-URL">URL<span><a href="#label-URL">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#url</code> method returns the URL to the attached file, and returns <code>nil</code> if no file is attached.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">url</span> <span class="ruby-comment"># calls `attacher.get.url`</span></pre>

<h2 id="label-State">State<span><a href="#label-State">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can ask the attacher whether the currently attached file is cached or stored.</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">cached?</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">stored?</span></pre>

<h2 id="label-Validations">Validations<span><a href="#label-Validations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Whenever a file is assigned via <code>#assign</code> or <code>#set</code>, the file validations are automatically run, and you can access the validation errors through <code>#errors</code>:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">large_file</span>)&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">errors</span> <span class="ruby-comment">#=&gt; [&quot;is larger than 10 MB&quot;]</span></pre>

<h2 id="label-Promoting">Promoting<span><a href="#label-Promoting">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>After the attachment is assigned and you run validations, it should be promoted to permanent storage after the record is saved. You can use <code>#finalize</code> for that, since that will also automatically delete any previously attached files.</p>

<pre class="ruby"><span class="ruby-comment"># Replaces previous attachment and replaces new</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">finalize</span></pre>

<p>This is normally automatically added to a callback by the ORM plugin when going through the model. Internally this calls <code>#promote</code>, which uploads a given <code>Shrine::UploadedFile</code> to permanent storage, and swaps it with the current attachment, unless a new file was attached in the meanwhile.</p>

<pre class="ruby"><span class="ruby-comment"># uploads cached file to permanent storage and replaces the current one</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">cached_file</span>, <span class="ruby-value">action:</span> <span class="ruby-value">:custom_name</span>)</pre>

<p>The <code>:action</code> parameter is optional; it can be used for triggering a certain processing block, or for additional context during instrumentation.</p>

<p>As a matter of fact, all additional options passed to <code>#promote</code> will be forwarded to <code>Shrine#upload</code>. So unless you&#39;re generating versions, you can do things like override metadata, set upload location, or pass upload options:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">promote</span> <span class="ruby-identifier">cached_file</span>,&#x000A;  <span class="ruby-value">metadata:</span>       { <span class="ruby-string">&quot;filename&quot;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;myfile.txt&quot;</span> },&#x000A;  <span class="ruby-value">location:</span>       <span class="ruby-string">&quot;custom/location&quot;</span>,&#x000A;  <span class="ruby-value">upload_options:</span> { <span class="ruby-value">acl:</span> <span class="ruby-string">&quot;public-read&quot;</span> }</pre>

<p>Internally <code>#promote</code> calls <code>#swap</code>, which will update the record with any uploaded file, but will reload the record to check if the current attachment hasn&#39;t changed (if the <code>backgrounding</code> plugin is loaded).</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">swap</span>(<span class="ruby-identifier">uploaded_file</span>)</pre>

<p>Both <code>#promote</code> and <code>#swap</code> are useful for <a href="/doc/migrating_storage.md#readme">file migrations</a>.</p>

<h2 id="label-Backgrounding">Backgrounding<span><a href="#label-Backgrounding">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When the <code>backgrounding</code> plugin is loaded, it allows you to promote and delete files in the background, and the corresponding methods are prefixed with <code>_</code>:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:backgrounding</span>&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">DeleteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }</pre>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">_promote</span>(<span class="ruby-identifier">cached_file</span>)  <span class="ruby-comment"># calls the registered `Attacher.promote` block</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">_delete</span>(<span class="ruby-identifier">uploaded_file</span>) <span class="ruby-comment"># calls the registered `Attacher.delete` block</span></pre>

<p>These are automatically used when using <a href="../../classes/Shrine.html"><code>Shrine</code></a> through models.</p>

<h2 id="label-Context">Context<span><a href="#label-Context">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The attacher sends <code>#context</code> to each upload/delete call to the uploader. By default it will hold <code>:record</code> and <code>:name</code>:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">context</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   record: #&lt;Photo...&gt;,</span>&#x000A;<span class="ruby-comment">#   name:   :image,</span>&#x000A;<span class="ruby-comment"># }</span></pre>

<p>However, you can change/add additional context to be sent when calling the uploaders:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">context</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-string">&quot;bar&quot;</span></pre>

<p>This is useful for example if you have immutable model instances, and you want to assign a new updated instance. For example both foreground and background <code>#promote</code> requires that the record is persisted (and its <code>#id</code> is present).</p>

<h2 id="label-Uploading+and+deleting">Uploading and deleting<span><a href="#label-Uploading+and+deleting">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Normally you can upload and delete directly by using the uploader.</p>

<pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:store</span>)&#x000A;<span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">image</span>) <span class="ruby-comment"># uploads the file to `:store` storage</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">uploaded_file</span>)         <span class="ruby-comment"># deletes the uploaded file from `:store`</span></pre>

<p>But the attacher also has wrapper methods for uploading and deleting, which also automatically pass in the attacher <code>#context</code> (which includes <code>:record</code> and <code>:name</code>):</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">cache!</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># uploads file to temporary storage</span>&#x000A;<span class="ruby-comment"># =&gt; #&lt;Shrine::UploadedFile: @data={&quot;storage&quot; =&gt; &quot;cache&quot;, ...}&gt;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">store!</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># uploads file to permanent storage</span>&#x000A;<span class="ruby-comment"># =&gt; #&lt;Shrine::UploadedFile: @data={&quot;storage&quot; =&gt; &quot;store&quot;, ...}&gt;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">uploaded_file</span>) <span class="ruby-comment"># deletes uploaded file from storage</span></pre>

<p>These methods only upload/delete files, they don&#39;t write to record&#39;s data column. You can also pass additional options for <code>Shrine#upload</code> and <code>Shrine#delete</code>:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">cache!</span>(<span class="ruby-identifier">file</span>, <span class="ruby-value">upload_options:</span> { <span class="ruby-value">acl:</span> <span class="ruby-string">&quot;public-read&quot;</span> })&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">store!</span>(<span class="ruby-identifier">file</span>, <span class="ruby-value">location:</span> <span class="ruby-string">&quot;custom/location&quot;</span>)&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">uploaded_file</span>, <span class="ruby-value">foo:</span> <span class="ruby-string">&quot;bar&quot;</span>)</pre>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
