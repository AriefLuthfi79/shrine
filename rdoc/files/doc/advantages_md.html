<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>advantages.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>advantages.md
</h1>
<div class='paths'>
doc/advantages.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2019-09-22 14:25:18 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Advantages+of+Shrine">Advantages of <a href="../../classes/Shrine.html"><code>Shrine</code></a><span><a href="#label-Advantages+of+Shrine">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>There are many existing file upload solutions for Ruby out there – <a href="https://github.com/thoughtbot/paperclip">Paperclip</a>, <a href="https://github.com/carrierwaveuploader/carrierwave">CarrierWave</a>, <a target="_top" href="http://markevans.github.io/dragonfly/">Dragonfly</a>, <a href="https://github.com/refile/refile">Refile</a>, and <a href="https://github.com/rails/rails/tree/master/activestorage#active-storage">Active Storage</a>, to name the most popular ones. This guide will attempt to cover some of the main advantages that <a href="../../classes/Shrine.html"><code>Shrine</code></a> offers compared to these alternatives.</p>

<h2 id="label-Generality">Generality<span><a href="#label-Generality">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Many alternative file upload solutions are coupled to either Rails (Active Storage) or Active Record itself (Paperclip, Dragonfly). This is not ideal, as Rails-specific solutions fragment the Ruby community between developers that use Rails and developers that don&#39;t. There are many great web frameworks (<a target="_top" href="http://sinatrarb.com">Sinatra</a>, <a target="_top" href="http://roda.jeremyevans.net">Roda</a>, <a target="_top" href="http://cuba.is">Cuba</a>, <a target="_top" href="http://hanamirb.org">Hanami</a>, <a href="https://github.com/ruby-grape/grape">Grape</a>) and database libraries (<a target="_top" href="http://sequel.jeremyevans.net">Sequel</a>, <a target="_top" href="http://rom-rb.org">ROM</a>, <a href="https://github.com/hanami/model">Hanami::Model</a>) out there that people use instead of Rails and Active Record.</p>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a>, on the other hand, doesn&#39;t make any assumptions about which web framework or ORM you&#39;re using. Any web-specific functionality is implemented on top of <a href="https://rack.github.io">Rack</a>, the Ruby web server interface that powers all the popular Ruby web frameworks (including Rails). The integrations for specific ORMs are provided as plugins.</p>

<pre class="ruby"><span class="ruby-comment"># Rack-based plugins</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:upload_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:presign_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:download_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:derivation_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:rack_response</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:rack_file</span>&#x000A;&#x000A;<span class="ruby-comment"># ORM plugins</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:activerecord</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:sequel</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:mongoid</span> <span class="ruby-comment"># https://github.com/shrinerb/shrine-mongoid</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:hanami</span> <span class="ruby-comment"># https://github.com/katafrakt/hanami-shrine</span></pre>

<h2 id="label-Simplicity">Simplicity<span><a href="#label-Simplicity">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Where some popular file attachment libraries have <a href="https://en.wikipedia.org/wiki/God_object">god objects</a> (<code>CarrierWave::Uploader::Base</code> and <code>Paperclip::Attachment</code>), <a href="../../classes/Shrine.html"><code>Shrine</code></a> has several core classes, each with a clear set of responsibilities:</p>
<ul><li>
<p>Storage classes encapsulate file operations for the underlying service</p>
</li><li>
<p><code>Shrine</code> handles uploads and manages plugins</p>
</li><li>
<p><code>Shrine::UploadedFile</code> repesents a file that was uploaded to a storage</p>
</li><li>
<p><code>Shrine::Attacher</code> handles attaching files to records</p>
</li><li>
<p><code>Shrine::Attachment</code> adds convenience methods to model instances</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>          <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">storage</span>  <span class="ruby-comment">#=&gt; #&lt;Shrine::Storage::S3&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">uploader</span> <span class="ruby-comment">#=&gt; #&lt;Shrine&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_attacher</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::Attacher&gt;</span></pre>

<p>The attachment functionality is decoupled from persistence and storage, which makes it much easier to reason about. Also, special care was taken to make integrating new storages and ORMs possible with minimal amount of code.</p>

<h2 id="label-Modularity">Modularity<span><a href="#label-Modularity">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> uses a <a href="https://twin.github.io/the-plugin-system-of-sequel-and-roda/">plugin system</a> that allows you to pick and choose the features that you want. Moreover, you&#39;ll only be loading code for the features you&#39;ve selected, which means that <a href="../../classes/Shrine.html"><code>Shrine</code></a> will generally much faster than the alternatives.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:instrumentation</span>&#x000A;&#x000A;<span class="ruby-comment"># translates to</span>&#x000A;&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/plugins/instrumentation&quot;</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Plugins</span><span class="ruby-operator">::</span><span class="ruby-constant">Instrumentation</span></pre>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> recommends a certain type of attachment flow, but it still offers good low-level abstractions that give you the flexibility to build your own attachment flow.</p>

<pre>uploaded_file = ImageUploader.upload(image, :store) # metadata extraction, upload location generation&#x000A;uploaded_file.id       #=&gt; &quot;44ccafc10ce6a4ff22829e8f579ee6b9.jpg&quot;&#x000A;uplaoded_file.metadata #=&gt; { ... extracted metadata ... }&#x000A;data = uploaded_file.to_json # serialization&#x000A;# ...&#x000A;uploaded_file = ImageUploader.uploaded_file(data) # deserialization&#x000A;&#x000A;uploaded_file.url #=&gt; &quot;https://...&quot;&#x000A;uploaded_file.download { |tempfile| ... } # streaming download&#x000A;uploaded_file.delete</pre>

<h3 id="label-Dependencies">Dependencies<span><a href="#label-Dependencies">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> is very diligent when it comes to dependencies. It has two mandatory dependencies – <a href="https://github.com/janko/down">Down</a> and <a href="https://github.com/shrinerb/content_disposition">ContentDisposition</a> – which are loaded only by components that need them. Some <a href="../../classes/Shrine.html"><code>Shrine</code></a> plugins also require additional dependencies, but you only need to load them if you&#39;re using those plugins.</p>

<p>Moreover, <a href="../../classes/Shrine.html"><code>Shrine</code></a> often gives you the ability choose between multiple alternative dependencies for doing the same task. For example, the <code>determine_mime_type</code> plugin allows you to choose between the <a target="_top" href="http://linux.die.net/man/1/file">file</a> command, <a href="https://github.com/blackwinter/ruby-filemagic">FileMagic</a>, <a href="https://github.com/sdsykes/fastimage">FastImage</a>, <a href="https://github.com/minad/mimemagic">MimeMagic</a>, or <a href="https://github.com/basecamp/marcel">Marcel</a> gem for determining the MIME type, while the <code>store_dimensions</code> plugin can extract dimensions using <a href="https://github.com/sdsykes/fastimage">FastImage</a>, <a href="https://github.com/minimagick/minimagick">MiniMagick</a>, or <a href="https://github.com/libvips/ruby-vips">ruby-vips</a> gem.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:determine_mime_type</span>, <span class="ruby-value">analyzer:</span> <span class="ruby-value">:marcel</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:store_dimensions</span>,    <span class="ruby-value">analyzer:</span> <span class="ruby-value">:mini_magick</span></pre>

<p>This approach gives you control over your dependencies by allowing you to choose the combination that best suits your needs.</p>

<h2 id="label-Inheritance">Inheritance<span><a href="#label-Inheritance">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> is designed to handle any types of files. If you&#39;re accepting uploads of multiple types of files, such as videos and images, chances are that the logic for handling them will differ:</p>
<ul><li>
<p>small images can be processed on-the-fly, but large files should be processed in a background job</p>
</li><li>
<p>you might want to store different files to different storage services (images, documents, audios, videos)</p>
</li><li>
<p>extracting metadata might require different tools depending on the filetype</p>
</li></ul>

<p>With <a href="../../classes/Shrine.html"><code>Shrine</code></a> you can create isolated uploaders for each type of file. Plugins that you want to be applied to all uploaders can be applied globally, while other plugins would be loaded only for a specific uploader.</p>

<pre class="ruby"><span class="ruby-comment"># loaded for all plugins</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:activerecord</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:instrumentation</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># loaded only for ImageUploader</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:store_dimensions</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># loaded only for VideoUploader</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:default_storage</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:vimeo</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Most file attachment libraries give you the ability to process files either “on attachment” (Paperclip, CarrierWave) or “on-the-fly” (Dragonfly, Refile, Active Storage). However, you should ideally be able to choose both, because both approaches have their pros and cons. For example, on-the-fly processing is only suitable for fast processing (image thumbnails, document previews), longer running processing should be moved into a background job (video transcoding, raw images).</p>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> is the first file attachment library that has support for both processing on attachment and on-the-fly. So, if you&#39;re handling image uploads, you can choose to either generate a set of pre-defined image thumbnails in a background job:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">derivatives_processor</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">magick</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>.<span class="ruby-identifier">source</span>(<span class="ruby-identifier">original</span>)&#x000A;&#x000A;    {&#x000A;      <span class="ruby-value">large:</span>  <span class="ruby-identifier">magick</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">800</span>, <span class="ruby-value">800</span>),&#x000A;      <span class="ruby-value">medium:</span> <span class="ruby-identifier">magick</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">500</span>, <span class="ruby-value">500</span>),&#x000A;      <span class="ruby-value">small:</span>  <span class="ruby-identifier">magick</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">300</span>, <span class="ruby-value">300</span>),&#x000A;    }&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>(<span class="ruby-value">:large</span>)&#x000A;<span class="ruby-comment">#=&gt; &quot;https://s3.amazonaws.com/path/to/large.jpg&quot;</span></pre>

<p>or generate thumbnails on-demand:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">derivation</span> <span class="ruby-value">:thumbnail</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">file</span>, <span class="ruby-identifier">width</span>, <span class="ruby-identifier">height</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;      .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">file</span>)&#x000A;      .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-identifier">width</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">height</span>.<span class="ruby-identifier">to_i</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">derivation_url</span>(<span class="ruby-value">:thumbnail</span>, <span class="ruby-value">600</span>, <span class="ruby-value">400</span>)&#x000A;<span class="ruby-comment">#=&gt; &quot;.../thumbnail/600/400/eyJpZCI6ImZvbyIsInN0b3JhZ2UiOiJzdG9yZSJ9?signature=...&quot;</span></pre>

<h3 id="label-Image+processing">Image processing<span><a href="#label-Image+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Many file attachment libraries, such as CarrierWave, Paperclip, Dragonfly and Refile, implement their own image processing macros. Instead of creating yet another in-house implementation, the <strong><a href="https://github.com/janko/image_processing">ImageProcessing</a></strong> gem was created.</p>

<p>While the ImageProcessing gem was created for <a href="../../classes/Shrine.html"><code>Shrine</code></a>, it&#39;s completely generic and can be used standalone or with any other file upload library (e.g. Active Storage 6+ uses it). It takes care of many details for you, such as <a href="https://www.imagemagick.org/script/command-line-options.php#auto-orient">auto orienting</a> the input image and <a href="https://photography.tutsplus.com/tutorials/what-is-image-sharpening--cms-26627">sharpening</a> the thumbnails after they are resized.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">image</span>)&#x000A;  .<span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-value">400</span>, <span class="ruby-value">400</span>)&#x000A;  .<span class="ruby-identifier">call</span> <span class="ruby-comment"># convert input.jpg -auto-orient -resize 400x400&gt; -sharpen 0x1 output.jpg</span>&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> <span class="ruby-comment">#=&gt; #&lt;Tempfile:/var/folders/.../image_processing20180316-18446-1j247h6.png&gt;</span></pre>

<h4 id="label-libvips">libvips<span><a href="#label-libvips">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Probably the biggest ImageProcessing feature is the support for <strong><a target="_top" href="http://libvips.github.io/libvips/">libvips</a></strong>. libvips is a full-featured image processing library like ImageMagick, with impressive performance characteristics – it&#39;s often <strong>multiple times faster</strong> than ImageMagick and has low memory usage (see <a href="https://github.com/libvips/libvips/wiki/Why-is-libvips-quick">Why is libvips quick</a>).</p>

<p>The <code>ImageProcessing::Vips</code> backend implements the same API as <code>ImageProcessing::MiniMagick</code>, so you can easily swap one for the other.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/vips&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">Vips</span>&#x000A;  .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">image</span>)&#x000A;  .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">400</span>, <span class="ruby-value">400</span>)</pre>

<h3 id="label-Other+processors">Other processors<span><a href="#label-Other+processors">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Both processing “on upload” and “on-the-fly” work in a way that you define a Ruby block, which accepts a source file and is expected to return a processed file. How you&#39;re going to do the processing is entirely up to you.</p>

<p>This allows you to use any tool you want. For example, you could implement video transcoding:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">derivatives_processor</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">transcoded</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span> [<span class="ruby-string">&quot;transcoded&quot;</span>, <span class="ruby-string">&quot;.mp4&quot;</span>]&#x000A;    <span class="ruby-identifier">screenshot</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span> [<span class="ruby-string">&quot;screenshot&quot;</span>, <span class="ruby-string">&quot;.jpg&quot;</span>]&#x000A;&#x000A;    <span class="ruby-identifier">movie</span> = <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">original</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">transcode</span>(<span class="ruby-identifier">transcoded</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">screenshot</span>(<span class="ruby-identifier">screenshot</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;    { <span class="ruby-value">transcoded:</span> <span class="ruby-identifier">transcoded</span>, <span class="ruby-value">screenshot:</span> <span class="ruby-identifier">screenshot</span> }&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Metadata+-26+Validation">Metadata &amp; Validation<span><a href="#label-Metadata+-26+Validation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> automatically <a href="/doc/metadata.md#readme">extracts metadata</a> from each uploaded file, including derivatives like image thumbnails, and saves them into the database column. In addition to filename, filesize, and MIME type that are extracted by default, you can also extract <a href="/doc/plugins/store_dimensions.md#readme">image dimensions</a>, or your own <a href="/doc/plugins/add_metadata.md#readme">custom metadata</a>.</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &quot;size&quot; =&gt; 42487494,</span>&#x000A;<span class="ruby-comment">#   &quot;filename&quot; =&gt; &quot;nature.jpg&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;image/jpeg&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;width&quot; =&gt; 600,</span>&#x000A;<span class="ruby-comment">#   &quot;height&quot; =&gt; 400,</span>&#x000A;<span class="ruby-comment">#   ...</span>&#x000A;<span class="ruby-comment"># }</span></pre>

<p>For common metadata you can use the built-in <a href="/doc/plugins/validation_helpers.md#readme">validators</a>, but you can also <a href="/doc/validation.md#custom-validations">validate any custom metadata</a>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># validation macros</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">10</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>&#x000A;    <span class="ruby-identifier">validate_mime_type</span> <span class="ruby-node">%W[application/pdf]</span>&#x000A;&#x000A;    <span class="ruby-comment"># custom validations</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">file</span>[<span class="ruby-string">&quot;page_count&quot;</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">30</span>&#x000A;      <span class="ruby-identifier">errors</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;must not have more than 30 pages&quot;</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Backgrounding">Backgrounding<span><a href="#label-Backgrounding">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In most file upload solutions background processing was an afterthought, which resulted in complex implementations. <a href="../../classes/Shrine.html"><code>Shrine</code></a> was designed with backgrounding feature in mind from day one. It is supported via the <a href="/doc/plugins/backgrounding.md#readme">backgrounding</a> plugin and can be used with <a href="https://github.com/shrinerb/shrine/wiki/Backgrounding-Libraries">any backgrounding library</a>.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote_block</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_later</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>, <span class="ruby-identifier">record</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">file_data</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">PromoteJob</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveJob</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">perform</span>(<span class="ruby-identifier">attacher_class</span>, <span class="ruby-identifier">record</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">file_data</span>)&#x000A;    <span class="ruby-identifier">attacher</span> = <span class="ruby-identifier">attacher_class</span>.<span class="ruby-identifier">retrieve</span>(<span class="ruby-value">model:</span> <span class="ruby-identifier">record</span>, <span class="ruby-value">name:</span> <span class="ruby-identifier">name</span>, <span class="ruby-value">file:</span> <span class="ruby-identifier">file_data</span>)&#x000A;    <span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">create_derivatives</span> <span class="ruby-comment"># perform processing</span>&#x000A;    <span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">atomic_promote</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Direct+Uploads">Direct Uploads<span><a href="#label-Direct+Uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> doesn&#39;t come with a plug-and-play JavaScript solution for client-side uploads like Refile and Active Storage, but instead it adopts <strong><a href="https://uppy.io">Uppy</a></strong>. Uppy is a modern JavaScript file upload library, which offers support for uploading to <a href="https://uppy.io/docs/aws-s3/">AWS S3</a>, to a <a href="https://uppy.io/docs/xhrupload/">custom endpoint</a>, or even to a <a href="https://uppy.io/docs/tus/">resumable endpoint</a>. It comes with a set of UI components, ranging from a simple <a href="https://uppy.io/examples/statusbar/">status bar</a> to a full-featured <a href="https://uppy.io/examples/dashboard/">dashboard</a>. Since Uppy is maintained by the wide JavaScript community, it&#39;s generally a better choice than any homegrown solution.</p>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> provides Rack components for uploads that integrate nicely with Uppy. So, whether you want Uppy to upload directly <a href="/doc/plugins/upload_endpoint.md#readme">to your app</a>, or you want to authorize direct uploads <a href="/doc/plugins/presign_endpoint.md#readme">to the cloud</a>, <a href="../../classes/Shrine.html"><code>Shrine</code></a> has it streamlined.</p>

<h3 id="label-Resumable+uploads">Resumable uploads<span><a href="#label-Resumable+uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If your users are uploading large files, flaky internet connections can cause uploads to fail halfway, which can be a frustrating user experience. To fix this problem, <a href="https://transloadit.com">Transloadit</a> company has created an open HTTP-based protocol for resumable uploads – <strong><a href="https://tus.io">tus</a></strong>. There are already countless client and server <a href="https://tus.io/implementations.html">implementations</a> of the protocol in various languages.</p>

<p>So, if you&#39;re expecting large file uploads, you can use Uppy as a <a href="https://uppy.io/docs/tus/">JavaScript client</a> and have it upload to <a href="https://github.com/janko/tus-ruby-server">Ruby server</a>, then attach uploaded files using the handy <a href="https://github.com/shrinerb/shrine-tus">Shrine integration</a>. <a href="../../classes/Shrine.html"><code>Shrine</code></a> handles uploads and downloads in a streaming fashion, so you can expect low memory usage.</p>

<p>Alternatively, you can have <a href="https://github.com/janko/uppy-s3_multipart">resumable multipart uploads directly to S3</a>.</p>

<h2 id="label-Summary">Summary<span><a href="#label-Summary">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> is general purpose, it can integrate with any web framework and any database library. It has core classes with clearly defined responsibilities, which provide both higher and lower level abstractions. The functionality is very modular, you can pick and choose features that you need.</p>

<p>With <a href="../../classes/Shrine.html"><code>Shrine</code></a> you can process both on attachment and on-the-fly, depending on what is more suitable for your requirements. Processing is just a functional transformation, which makes it easier to use the processing tool of your choice. You can also move processing into a background job.</p>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> automatically extracts metadata from the main file and any processed files. In addition to built-in metadata you can also extract any custom metadata. Any extracted metadata can be validated on attachment.</p>

<p>Finally, <a href="../../classes/Shrine.html"><code>Shrine</code></a> integrates with Uppy, a full-featured JavaScript file upload library. It allows you to do direct uploads to your app or to S3. For large files you can also make the uploads resumable.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
