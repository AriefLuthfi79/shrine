<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>processing.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>processing.md
</h1>
<div class='paths'>
doc/processing.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2019-06-24 18:13:05 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-File+Processing">File Processing<span><a href="#label-File+Processing">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> allows you to process files in two ways. One is processing “<a href="#processing-on-upload">on upload</a>”, where the processing gets triggered when the file is attached to a record. The other is “<a href="#on-the-fly-processing">on-the-fly</a>” processing, where the processing is performed lazily at the moment the file is requested.</p>

<p>With both ways you need to define some kind of processing block, which accepts a source file and is expected to return the processed result file.</p>

<pre class="ruby"><span class="ruby-identifier">some_process_block</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">source_file</span><span class="ruby-operator">|</span>&#x000A; <span class="ruby-comment"># process source file and return the result</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>How you&#39;re going to implement processing is entirely up to you. For images it&#39;s recommended to use the <strong><a href="https://github.com/janko/image_processing">ImageProcessing</a></strong> gem, which provides wrappers for processing with <a target="_top" href="http://www.graphicsmagick.org">ImageMagick}[https://www.imagemagick.org]/{GraphicsMagick</a> (using the <a href="https://github.com/minimagick/minimagick">MiniMagick</a> gem) or <a target="_top" href="http://libvips.github.io/libvips/">libvips</a> (using the <a href="https://github.com/libvips/ruby-vips">ruby-vips</a> gem; see the <a href="#libvips">libvips section</a>). Here is an example of generating a thumbnail with ImageProcessing:</p>

<pre>$ brew install imagemagick</pre>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_processing&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.0&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">image</span>)&#x000A;  .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">600</span>, <span class="ruby-value">400</span>)&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> <span class="ruby-comment">#=&gt; #&lt;Tempfile:...&gt; (a 600x400 thumbnail of the source image)</span></pre>

<h2 id="label-Processing+on+upload">Processing on upload<span><a href="#label-Processing+on+upload">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> allows you to process files before they&#39;re uploaded to a storage. It&#39;s generally best to process cached files when they&#39;re being promoted to permanent storage, because (a) at that point the file has already been successfully <a href="/doc/validation.md#readme">validated</a>, (b) the parent record has been saved and the database transaction has been committed, and © this can be delayed into a <a href="/doc/plugins/backgrounding.md#readme">background job</a>.</p>

<p>You can define processing using the <code>processing</code> plugin, which we&#39;ll use to hook into the <code>:store</code> phase (when cached file is uploaded to permanent storage).</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">io</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile ...&gt;</span>&#x000A;    <span class="ruby-identifier">context</span> <span class="ruby-comment">#=&gt; {:record=&gt;#&lt;Photo...&gt;,:name=&gt;:image,...}</span>&#x000A;&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>The processing block yields two arguments: a <a target="_top" href="http://shrinerb.com/rdoc/classes/Shrine/UploadedFile/InstanceMethods.html">Shrine::UploadedFile</a> object representing the file uploaded to temporary storage, and a Hash containing additional data such as the model instance and attachment name. The block result should be file(s) that will be uploaded to permanent storage.</p>

<h3 id="label-Versions">Versions<span><a href="#label-Versions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Let&#39;s say we&#39;re handling images, and want to generate thumbnails of various dimensions. In this case we can use the ImageProcessing gem to generate the thumbnails, and return a hash of processed files at the end of the block. We&#39;ll need to load the <code>versions</code> plugin which extends <a href="../../classes/Shrine.html"><code>Shrine</code></a> with the ability to handle collections of files inside the same attachment.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:processing</span> <span class="ruby-comment"># allows hooking into promoting</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:versions</span>   <span class="ruby-comment"># enable Shrine to handle a hash of files</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:delete_raw</span> <span class="ruby-comment"># delete processed files after uploading</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">versions</span> = { <span class="ruby-value">original:</span> <span class="ruby-identifier">io</span> } <span class="ruby-comment"># retain original</span>&#x000A;&#x000A;    <span class="ruby-comment"># download the uploaded file from the temporary storage</span>&#x000A;    <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">pipeline</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>.<span class="ruby-identifier">source</span>(<span class="ruby-identifier">original</span>)&#x000A;&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:large</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">800</span>, <span class="ruby-value">800</span>)&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:medium</span>] = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:small</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-identifier">versions</span> <span class="ruby-comment"># return the hash of processed files</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p><strong>NOTE: It&#39;s recommended to always keep the original file, just in case you&#39;ll ever need to reprocess it.</strong></p>

<h3 id="label-Conditional+processing">Conditional processing<span><a href="#label-Conditional+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The process block yields the attached file uploaded to temporary storage, so we have information like file extension and MIME type available. Together with ImageProcessing&#39;s chainable API, it&#39;s easy to do conditional proccessing.</p>

<p>For example, let&#39;s say we want our thumbnails to be either JPEGs or PNGs, and we also want to save JPEGs as progressive (interlaced). Here&#39;s how the code for this might look like:</p>

<pre class="ruby"><span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">versions</span> = { <span class="ruby-value">original:</span> <span class="ruby-identifier">io</span> }&#x000A;&#x000A;  <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">pipeline</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">Vips</span>.<span class="ruby-identifier">source</span>(<span class="ruby-identifier">original</span>)&#x000A;&#x000A;    <span class="ruby-comment"># Shrine::UploadedFile object contains information about the MIME type</span>&#x000A;    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">mime_type</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;image/png&quot;</span>&#x000A;      <span class="ruby-identifier">pipeline</span> = <span class="ruby-identifier">pipeline</span>&#x000A;        .<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;jpeg&quot;</span>)&#x000A;        .<span class="ruby-identifier">saver</span>(<span class="ruby-value">interlace:</span> <span class="ruby-keyword">true</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-identifier">versions</span>[<span class="ruby-value">:large</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">800</span>, <span class="ruby-value">800</span>)&#x000A;    <span class="ruby-identifier">versions</span>[<span class="ruby-value">:medium</span>] = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;    <span class="ruby-identifier">versions</span>[<span class="ruby-value">:small</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">versions</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h3 id="label-Processing+other+file+types">Processing other file types<span><a href="#label-Processing+other+file+types">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>So far we&#39;ve only been talking about processing images. However, there is nothing image-specific in Shrine&#39;s processing API, you can just as well process any other types of files. The processing tool doesn&#39;t need to have any special <a href="../../classes/Shrine.html"><code>Shrine</code></a> integration, the ImageProcessing gem that we saw earlier is a completely generic gem.</p>

<p>To demonstrate, here is an example of transcoding videos using <a href="https://github.com/streamio/streamio-ffmpeg">streamio-ffmpeg</a>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;streamio-ffmpeg&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;tempfile&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:versions</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:delete_raw</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">versions</span> = { <span class="ruby-value">original:</span> <span class="ruby-identifier">io</span> }&#x000A;&#x000A;    <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">transcoded</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;transcoded&quot;</span>, <span class="ruby-string">&quot;.mp4&quot;</span>], <span class="ruby-value">binmode:</span> <span class="ruby-keyword">true</span>)&#x000A;      <span class="ruby-identifier">screenshot</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;screenshot&quot;</span>, <span class="ruby-string">&quot;.jpg&quot;</span>], <span class="ruby-value">binmode:</span> <span class="ruby-keyword">true</span>)&#x000A;&#x000A;      <span class="ruby-identifier">movie</span> = <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">original</span>.<span class="ruby-identifier">path</span>)&#x000A;      <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">transcode</span>(<span class="ruby-identifier">transcoded</span>.<span class="ruby-identifier">path</span>)&#x000A;      <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">screenshot</span>(<span class="ruby-identifier">screenshot</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;      [<span class="ruby-identifier">transcoded</span>, <span class="ruby-identifier">screenshot</span>].<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:open</span>) <span class="ruby-comment"># refresh file descriptors</span>&#x000A;&#x000A;      <span class="ruby-identifier">versions</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-value">transcoded:</span> <span class="ruby-identifier">transcoded</span>, <span class="ruby-value">screenshot:</span> <span class="ruby-identifier">screenshot</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-identifier">versions</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-On-the-fly+processing">On-the-fly processing<span><a href="#label-On-the-fly+processing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Generating image thumbnails on upload can be a pain to maintain, because whenever you need to add a new version or change an existing one, you need to retroactively apply it to all existing uploads (see the <a href="/doc/regenerating_versions.md#readme">Reprocessing Versions</a> guide for more details).</p>

<p>As an alternative, it&#39;s very common to instead generate thumbnails dynamically as they&#39;re requested, and then cache them for future requests. This strategy is known as “on-the-fly processing”, and it&#39;s suitable for generating thumbnails or document previews.</p>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> provides on-the-fly processing functionality via the <a href="/doc/plugins/derivation_endpoint.md#readme">derivation_endpoint</a> plugin. The basic setup is the following:</p>
<ol><li>
<p>load the plugin with a secret key and a path prefix for the endpoint</p>
</li><li>
<p>mount the endpoint into your main app&#39;s router</p>
</li><li>
<p>define a processing block for the type files you want to generate</p>
</li></ol>

<p>Together it might look something like this:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:derivation_endpoint</span>,&#x000A;    <span class="ruby-value">secret_key:</span> <span class="ruby-string">&quot;&lt;YOUR SECRET KEY&gt;&quot;</span>,&#x000A;    <span class="ruby-value">prefix:</span>     <span class="ruby-string">&quot;derivations/image&quot;</span>&#x000A;&#x000A;  <span class="ruby-identifier">derivation</span> <span class="ruby-value">:thumbnail</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">file</span>, <span class="ruby-identifier">width</span>, <span class="ruby-identifier">height</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;      .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">file</span>)&#x000A;      .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-identifier">width</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">height</span>.<span class="ruby-identifier">to_i</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-comment"># config/routes.rb (Rails)</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">derivation_endpoint</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;derivations/image&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Now you can generate thumbnail URLs from attached files, and the actual thumbnail will be generated when the URL is requested:</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">derivation_url</span>(<span class="ruby-value">:thumbnail</span>, <span class="ruby-string">&quot;600&quot;</span>, <span class="ruby-string">&quot;400&quot;</span>)&#x000A;<span class="ruby-comment">#=&gt; &quot;/derivations/image/thumbnail/600/400/eyJpZCI6ImZvbyIsInN0b3JhZ2UiOiJzdG9yZSJ9?signature=...&quot;</span></pre>

<p>The plugin is highly customizable, be sure to check out the <a href="/doc/plugins/derivation_endpoint.md#readme">documentation</a>, especially the <a href="/doc/plugins/derivation_endpoint.md#performance">performance section</a>.</p>

<h2 id="label-Extras">Extras<span><a href="#label-Extras">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-libvips">libvips<span><a href="#label-libvips">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>As mentioned, ImageProcessing gem also has an alternative backend for processing images with <strong><a target="_top" href="http://libvips.github.io/libvips/">libvips</a></strong>. libvips is a full-featured image processing library like ImageMagick, with impressive performance characteristics – it&#39;s often <strong>multiple times faster</strong> than ImageMagick and has low memory usage (see <a href="https://github.com/libvips/libvips/wiki/Why-is-libvips-quick">Why is libvips quick</a>).</p>

<p>Using libvips is as easy as installing it and switching to the <code>ImageProcessing::Vips</code> backend:</p>

<pre>$ brew install vips</pre>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_processing&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.0&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/vips&quot;</span>&#x000A;&#x000A;<span class="ruby-comment"># all we did was replace `ImageProcessing::MiniMagick` with `ImageProcessing::Vips`</span>&#x000A;<span class="ruby-identifier">thumbnail</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">Vips</span>&#x000A;  .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">image</span>)&#x000A;  .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">600</span>, <span class="ruby-value">400</span>)&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> <span class="ruby-comment">#=&gt; #&lt;Tempfile:...&gt; (a 600x400 thumbnail of the source image)</span></pre>

<h3 id="label-Optimizing+thumbnails">Optimizing thumbnails<span><a href="#label-Optimizing+thumbnails">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you&#39;re generating image thumbnails, you can additionally use the <a href="https://github.com/toy/image_optim">image_optim</a> gem to further reduce their filesize:</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_processing&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.0&quot;</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_optim&quot;</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_optim_pack&quot;</span> <span class="ruby-comment"># precompiled binaries</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  .<span class="ruby-identifier">source</span>(<span class="ruby-identifier">image</span>)&#x000A;  .<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">600</span>, <span class="ruby-value">400</span>)&#x000A;&#x000A;<span class="ruby-identifier">image_optim</span> = <span class="ruby-constant">ImageOptim</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">image_optim</span>.<span class="ruby-identifier">optimize_image!</span>(<span class="ruby-identifier">thumbnail</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;<span class="ruby-identifier">thumbnail</span>.<span class="ruby-identifier">open</span> <span class="ruby-comment"># refresh file descriptor</span>&#x000A;<span class="ruby-identifier">thumbnail</span></pre>

<h3 id="label-External+processing">External processing<span><a href="#label-External+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Since processing is so dynamic, you&#39;re not limited to using the ImageProcessing gem, you can also use a 3rd-party service to generate thumbnails for you. Here is an example of generating thumbnails on-the-fly using <a href="https://imageoptim.com/api">ImageOptim.com</a> (not to be confused with the <a href="https://github.com/toy/image_optim">image_optim</a> gem):</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;down&quot;</span>, <span class="ruby-string">&quot;~&gt; 4.4&quot;</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;http&quot;</span>, <span class="ruby-string">&quot;~&gt; 4.0&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;down/http&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:derivation_endpoint</span>,&#x000A;    <span class="ruby-value">secret_key:</span> <span class="ruby-string">&quot;secret&quot;</span>,&#x000A;    <span class="ruby-value">prefix:</span>     <span class="ruby-string">&quot;derivations/image&quot;</span>,&#x000A;    <span class="ruby-value">download:</span>   <span class="ruby-keyword">false</span>&#x000A;&#x000A;  <span class="ruby-identifier">derivation</span> <span class="ruby-value">:thumbnail</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">source</span>, <span class="ruby-identifier">width</span>, <span class="ruby-identifier">height</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># generate thumbnails using ImageOptim.com</span>&#x000A;    <span class="ruby-identifier">down</span> = <span class="ruby-constant">Down</span><span class="ruby-operator">::</span><span class="ruby-constant">Http</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">method:</span> <span class="ruby-value">:post</span>)&#x000A;    <span class="ruby-identifier">down</span>.<span class="ruby-identifier">download</span>(<span class="ruby-node">&quot;https://im2.io/&lt;USERNAME&gt;/#{width}x#{height}/#{source.url}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h3 id="label-Cloudinary">Cloudinary<span><a href="#label-Cloudinary">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="https://cloudinary.com">Cloudinary</a> is a popular commercial service for on-the-fly image processing, so it&#39;s a good alternative to the <code>derivation_endpoint</code> plugin. The <a href="https://github.com/shrinerb/shrine-cloudinary">shrine-cloudinary</a> gem provides a <a href="../../classes/Shrine.html"><code>Shrine</code></a> storage that we can set for our temporary and permanent storage:</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;shrine-cloudinary&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;cloudinary&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/cloudinary&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Cloudinary</span>.<span class="ruby-identifier">config</span>(&#x000A;  <span class="ruby-value">cloud_name:</span> <span class="ruby-string">&quot;&lt;YOUR_CLOUD_NAME&gt;&quot;</span>,&#x000A;  <span class="ruby-value">api_key:</span>    <span class="ruby-string">&quot;&lt;YOUR_API_KEY&gt;&quot;</span>,&#x000A;  <span class="ruby-value">api_secret:</span> <span class="ruby-string">&quot;&lt;YOUR_API_SECRET&gt;&quot;</span>,&#x000A;)&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-value">cache:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Cloudinary</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;cache&quot;</span>),&#x000A;  <span class="ruby-value">store:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Cloudinary</span>.<span class="ruby-identifier">new</span>,&#x000A;}</pre>

<p>Now when we upload our images to Cloudinary, we can generate URLs with various processing parameters:</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">url</span>(<span class="ruby-value">width:</span> <span class="ruby-value">100</span>, <span class="ruby-value">height:</span> <span class="ruby-value">100</span>, <span class="ruby-value">crop:</span> <span class="ruby-value">:fit</span>)&#x000A;<span class="ruby-comment">#=&gt; &quot;http://res.cloudinary.com/myapp/image/upload/w_100,h_100,c_fit/nature.jpg&quot;</span></pre>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
